<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content=",,," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Kurento是什么Kurento是一个WebRTC媒体服务器，并且为网页、智能手机平台开发高级视频应用程序提供一组客户端api。Kurento的特性包括群组通信、转码、录音、混合、广播和音频流的路由。Kurento还提供先进的媒体处理能力，包括计算机视觉、视频索引、增强现实和语音分析。Kurento的模块化架构简化了第三方媒体处理算法(即语音识别、情感分析、人脸识别等)的集成，应用程序开发人员可">
<meta name="keywords" content="Kurento,WebRTC,Java">
<meta property="og:type" content="website">
<meta property="og:title" content="Kurento v6.6.1 不完全翻译">
<meta property="og:url" content="http://yoursite.com/Kurento-v6-6-1-不完全翻译.html">
<meta property="og:site_name" content="bboyjing&#39;s blog">
<meta property="og:description" content="Kurento是什么Kurento是一个WebRTC媒体服务器，并且为网页、智能手机平台开发高级视频应用程序提供一组客户端api。Kurento的特性包括群组通信、转码、录音、混合、广播和音频流的路由。Kurento还提供先进的媒体处理能力，包括计算机视觉、视频索引、增强现实和语音分析。Kurento的模块化架构简化了第三方媒体处理算法(即语音识别、情感分析、人脸识别等)的集成，应用程序开发人员可">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/media-server-intro.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/media-server-capabilities.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/kurento-clients-connection.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/kurento-basic-toolbox.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-screenshot.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-pipeline.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-signaling.png">
<meta property="og:image" content="http://7xvxof.com1.z0.glb.clouddn.com/HelloWorld.png">
<meta property="og:updated_time" content="2017-11-17T04:08:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kurento v6.6.1 不完全翻译">
<meta name="twitter:description" content="Kurento是什么Kurento是一个WebRTC媒体服务器，并且为网页、智能手机平台开发高级视频应用程序提供一组客户端api。Kurento的特性包括群组通信、转码、录音、混合、广播和音频流的路由。Kurento还提供先进的媒体处理能力，包括计算机视觉、视频索引、增强现实和语音分析。Kurento的模块化架构简化了第三方媒体处理算法(即语音识别、情感分析、人脸识别等)的集成，应用程序开发人员可">
<meta name="twitter:image" content="http://7xvxof.com1.z0.glb.clouddn.com/media-server-intro.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/Kurento-v6-6-1-不完全翻译.html"/>





  <title>
  

  
    Kurento v6.6.1 不完全翻译 | bboyjing's blog
  
</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bboyjing's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
  <header class="post-header">

	<h2 class="post-title" itemprop="name headline">Kurento v6.6.1 不完全翻译</h2>



</header>

    
    
      <h3 id="Kurento是什么"><a href="#Kurento是什么" class="headerlink" title="Kurento是什么"></a>Kurento是什么</h3><p>Kurento是一个WebRTC媒体服务器，并且为网页、智能手机平台开发高级视频应用程序提供一组客户端api。Kurento的特性包括群组通信、转码、录音、混合、广播和音频流的路由。<br>Kurento还提供先进的媒体处理能力，包括计算机视觉、视频索引、增强现实和语音分析。Kurento的模块化架构简化了第三方媒体处理算法(即语音识别、情感分析、人脸识别等)的集成，应用程序开发人员可以透明地。将其作为Kurento的内置特性使用。<br>Kurento的核心元素是Kurento Media Server，它负责媒体传输、处理、加载和录制。它是基于GStreamer的低水平技术实现来优化资源消耗。它提供了以下特性：</p>
<ul>
<li>网络流协议，包括HTTP、RTP和WebRTC</li>
<li>群组通信(MCUs和SFUs功能)，支持媒体混合和媒体路由/分发HTTP、RTP和WebRTC</li>
<li>对计算视觉和增强现实滤波器的通用支持</li>
<li>对WebM和MP4格式的媒体存储支持写操作，并且能播放所有支持GStreamer的格式</li>
<li>可以在支持GStreamer编码的任意媒体间自动转换，包括VP8、H.264、H.263、AMR、OPUS、Speex、G.711等</li>
</ul>
<a id="more"></a>
<p>Kurento提供Java和JavaScript类库来用于在应用程序中控制Kurento媒体服务器。如果偏好其它编程语言，可以使用基于WebSocket和json-rpc的Kurento协议。<br>Kurento是开源的，根据Apache 2.0许可协议发布，源代码托管在<a href="https://github.com/Kurento" target="_blank" rel="external">GitHub</a>上。<br>如果想快速上手，最好的方式是安装Kurento媒体服务，并且跑通演示教程。可以选择喜欢的技术来构建多媒体应用程序:Java、Browser JavaScript或node.js。<br>如果想更多地弄清楚Kurento，可以查看高级文档。</p>
<h3 id="介绍Kurento"><a href="#介绍Kurento" class="headerlink" title="介绍Kurento"></a>介绍Kurento</h3><h4 id="WebRTC媒体服务"><a href="#WebRTC媒体服务" class="headerlink" title="WebRTC媒体服务"></a>WebRTC媒体服务</h4><p>WebRTC是一种开放源码技术，可以通过JavaScript API使WEB浏览器具有实时通信(RTC)功能。它被设想成一种点对点技术，使得浏览器可以在不需要任何基础设施的情况下直接通信。这个模型足以创建基本的应用程序，但在它上面很难实现像组通信、媒体流录制、媒体广播或媒体转换等功能。出于这个原因，许多应用程序需要使用媒体服务器。<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/media-server-intro.png" alt="media-server-intro"><br>从概念上讲，一个WebRTC媒体服务器是一种”多媒体中间件”（它是在通信双方的中间），媒体流量从源经过该中间节点再到目的地。媒体服务器能够处理媒体流和提供不同类型包括群组通信(将一个节点产生的媒体流流量分发到多个接收者，即充当Multi-Conference单元 MCU)、混合(将几个传入的流转成混合流)、转码(在彼此不兼容的客户端之间适配编码和格式)、记录(以一种持久化的方式储存媒体信息)等等。<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/media-server-capabilities.png" alt="media-server-capabilities"></p>
<h4 id="Kurento媒体服务"><a href="#Kurento媒体服务" class="headerlink" title="Kurento媒体服务"></a>Kurento媒体服务</h4><p>在Kurento架构的核心有一个名为Kurento media server(KMS)的媒体服务器。Kurento媒体服务器基于可插入的媒体处理功能，这意味着它所提供的任何功能都是可以被激活或停用的可插入模块。此外，开发人员可以无缝地创建具有扩展功能的新模块，并且可以动态插入。<br>kurento媒体服务器提供开箱、群组通信、混合、转码、录制和播放。此外，它还提供先进的媒体处理模块，包括计算机视觉、增强现实、阿尔法混合等等。</p>
<h4 id="Kurento-API、客户端和协议"><a href="#Kurento-API、客户端和协议" class="headerlink" title="Kurento API、客户端和协议"></a>Kurento API、客户端和协议</h4><p>Kurento媒体服务器的功能由Kurento API开放给应用程序开发人员。这个API是通过叫做Kurento客户端的类库实现的。Kurento提供两个开箱即用的客户端Java和JavaScript。如果使用的是其它语言，仍然可以通过直接使用Kurento协议来使用Kurento。该协议允许控制Kurento媒体服务器，它基于WebSocket和json-rpc等互联网标准。下面的图片展示了如何在三个场景中使用Kurento客户：</p>
<ul>
<li>直接在一个兼容的WebRTC的浏览器中使用Kurento JavaScript客户端</li>
<li>在Java EE应用服务器中使用Kurento Java客户端</li>
<li>在Node.js中使用Kurento JavaScript客户端</li>
</ul>
<p><img src="http://7xvxof.com1.z0.glb.clouddn.com/kurento-clients-connection.png" alt="kurento-clients-connection"><br>Kurento客户端是基于流媒体元素的概念。媒体元素具有特定的媒体功能。比如，WebRtcEndpoint流媒体元素具有发送/接收WebRTC媒体流的功能、RecorderEndpoint流媒体元素具有将接收到的任何媒体流保存到文件系统的功能、FaceOverlayFilter能够检测视频流的人脸并且能够在上面叠加一个具体的图像等等。Kurento公开了一个丰富的媒体元素工具箱，作为其API的一部分。下图列出其中一部分：<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/kurento-basic-toolbox.png" alt="kurento-basic-toolbox"><br>为了更好地理解这些概念，建议查看一下Kurento API和Kurento协议部分。您还可以对JavaDoc和JsDoc进行查询：</p>
<ul>
<li><a href="http://doc-kurento.readthedocs.io/en/stable/_static/langdoc/javadoc/index.html" target="_blank" rel="external">kurento-client-java</a> : Kurento Java客户端文档</li>
<li><a href="http://doc-kurento.readthedocs.io/en/stable/_static/langdoc/jsdoc/kurento-client-js/index.html" target="_blank" rel="external">kurento-client-js</a> : Kurento JavaScript客户端文档</li>
<li><a href="http://doc-kurento.readthedocs.io/en/stable/_static/langdoc/jsdoc/kurento-utils-js/index.html" target="_blank" rel="external">kurento-utils-js</a>: 一个实用的JavaScript库文档，旨在简化WebRTC应用程序的开发</li>
</ul>
<h4 id="使用Kurento创建应用程序"><a href="#使用Kurento创建应用程序" class="headerlink" title="使用Kurento创建应用程序"></a>使用Kurento创建应用程序</h4><p>从应用程序开发人员的角度来看，媒体元素就像乐高部件：只需要获取应用程序所需的元素，并将它们连接到所需的拓扑结构。在Kurento术语中，连接媒体元素的图形称为媒体管道。<br>因此，在创建一个管道时，开发人员需要确定他们想要使用的功能（媒体元素）和拓扑结构，确定哪些媒体元素为其他媒体元素（连通性）提供媒体。连接是通过connect原语控制的，暴露在所有kurento客户端API。其调用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sourceMediaElement.connect(sinkMediaElement)</div></pre></td></tr></table></figure></p>
<p>例如，如果想创建一个应用程序将WebRTC流记录到文件系统中，将需要两个媒体元素：WebRtcEndpoint和RecorderEndpoint。当客户端连接到应用程序时，需要实例化这些媒体元素，使WebRtcEndpoint接收的流输入到RecorderEndpoint(它能够将媒体流记录到文件系统中)。最后，需要连接它们，以便由前者接收的流输入到后面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebRtcEndpoint.connect(RecorderEndpoint)</div></pre></td></tr></table></figure></p>
<p>为了简化客户端中WebRTC流的处理，Kurento提供了一个名为WebRtcPeer的实用工具。然而，标准的WebRTC API(getUserMedia,RTCPeerConnection，等等)也可用于连接WebRtcEndpoints。更多信息请访问教程部分。</p>
<h3 id="安装Kurento媒体服务"><a href="#安装Kurento媒体服务" class="headerlink" title="安装Kurento媒体服务"></a>安装Kurento媒体服务</h3><p>Kurento媒体服务器(KMS)必须安装在Ubuntu 14.04 LTS(64位)上。为了安装最新的稳定的Kurento媒体服务器版本(6.6.1)，一次执行如下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo "deb http://ubuntu.kurento.org trusty kms6" | sudo tee /etc/apt/sources.list.d/kurento.list</div><div class="line">wget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install kurento-media-server-6.0</div></pre></td></tr></table></figure></p>
<p>现在，已经安装了Kurento媒体服务器。使用以下命令分别启动和停止它：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo service kurento-media-server-6.0 start</div><div class="line">sudo service kurento-media-server-6.0 stop</div></pre></td></tr></table></figure></p>
<p>如果Kurento媒体服务器位于NAT之后，您需要使用STUN或TURN来实现NAT遍历，参照<a href="http://doc-kurento.readthedocs.io/en/stable/installation_guide.html#stun-and-turn-servers" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Kurento教程"><a href="#Kurento教程" class="headerlink" title="Kurento教程"></a>Kurento教程</h3><p>本节教程展示如何使用Kurento框架来构建不同类型的WebRTC和多媒体应用程序，教程有三种风格：</p>
<ul>
<li>Java 这些应用程序基于Spring Boot构建，与客户端交互，托管了协调客户端通信和控制Kurento媒体服务器功能的逻辑</li>
<li>Browser JavaScript 这些应用程序在浏览器中执行，并直接与Kurento媒体服务器通信。在本教程中，所有的逻辑都由浏览器直接托管。因此，不需要应用服务器</li>
<li>Node.js 这些应用程序基于Node.js构建，与客户端交互，应用服务器负责协调客户端之间的通信，并为它们控制Kurento媒体服务器的功能</li>
</ul>
<p>下面的目标是跑通所有的例子，以Java为主，其它两项如果不影响测试，就不翻译了。</p>
<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>这是可以使用Kurento创建的最简单的WebRTC应用程序之一。它实现了一个WebRTC回环(WebRTC媒体流从客户端到Kurento并返回到客户端)。这个web应用程序的目的是为Java开发人员介绍使用Kurento编程的原则。</p>
<h5 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h5><p>需要如下步骤来启动项目：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Kurento/kurento-tutorial-java.git</div><div class="line">cd kurento-tutorial-java/kurento-hello-world</div><div class="line">git checkout 6.6.2</div><div class="line">mvn compile exec:java -Dkms.url=ws://kms_host:kms_port/kurento</div></pre></td></tr></table></figure></p>
<p>其中kms_host和kms_port分别为kurento媒体服务的地址和端口。<br>在支持WebRTC的浏览器中(Chrome,Firefox)打开URL <a href="https://localhost:8443/" target="_blank" rel="external">https://localhost:8443/</a> 即可测试。</p>
<h5 id="理解示例"><a href="#理解示例" class="headerlink" title="理解示例"></a>理解示例</h5><p>Kurento为开发人员提供了一个Kurento Java客户端来控制Kurento媒体服务器。这个客户端库可以用于任何类型的Java应用程序：WEB服务端、桌面端、安卓等。它兼容任何框架，如Java EE、Spring、Play、Vert.x、Swing和JavaFX。<br>这个hello world示例是可以使用Kurento创建的最简单的web应用程序之一。下图显示了这个演示运行的屏幕截图：<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-screenshot.png" alt="kurento-java-tutorial-1-helloworld-screenshot"><br>应用程序的接口(一个HTML web页面)由两个HTML5视频标签组成:一个显示本地流(由设备webcam捕获)，另一个显示由媒体服务器发送到客户端的远程流。<br>应用程序的逻辑很简单:本地流被发送到Kurento媒体服务器，该服务器将视频流原样返回给客户端。为了实现这种行为，我们需要创建由单个媒体元素组成的媒体管道，即WebRtcEndpoint，它具有交换全双工(双向)WebRTC媒体流的功能。此媒体元素与自身连接，以便它接收的媒体(来自浏览器)被发送回(浏览器)。这条媒体管道如下图所示：<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-pipeline.png" alt="kurento-java-tutorial-1-helloworld-pipeline"><br>这是一个web应用程序，因此它遵循客户端-服务器体系结构。客户端逻辑是用JavaScript实现的。服务端使用基于Spring Boot的应用程序来消费Kurento Java客户端，用于控制Kurento媒体服务。为了连接这些实体，使用了两个WebSocket。首先，在客户端和应用服务器之间创建一个WebSocket来实现自定义的信令协议。第二，另一个WebSocket用于执行Kurento Java客户端和Kurento媒体服务器之间的通信。这个通信使用的是Kurento协议。<br>下面的图表显示了一个完整的序列图，描述了JavaScript逻辑、应用服务器逻辑(Kurento Java客户端)和Kurento媒体服务之间的交互。<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/kurento-java-tutorial-1-helloworld-signaling.png" alt="kurento-java-tutorial-1-helloworld-signaling"><br>以下部分将深入分析此应用程序的服务器(Java)和客户端(JavaScript)代码。完整的源代码可以在<a href="https://github.com/Kurento/kurento-tutorial-java/tree/master/kurento-hello-world" target="_blank" rel="external">GitHub</a>中找到</p>
<h5 id="服务端逻辑"><a href="#服务端逻辑" class="headerlink" title="服务端逻辑"></a>服务端逻辑</h5><p>这个示例是使用Java作为服务端，基于Spring Boot，使用内嵌的Tomcat，从而简化了开发和部署过程。<br>在下面的图中，可以看到服务器端代码的类图:<br><img src="http://7xvxof.com1.z0.glb.clouddn.com/HelloWorld.png" alt="HelloWorld"><br>该示例的Main函数入口在HelloWorldApp类中。可以看到，KurentoClient在这个类中被实例化为Spring Bean。该bean用于创建Kurento媒体管道，用于向应用程序添加媒体功能。在这个实例化过程中，可以看到我们需要向客户端库指定Kurento媒体服务器的位置。其位置在KurentoClient.kmsUrlLoader中赋值，默认为ws://127.0.0.1:8888/kurento，可以通过-Dkms.url来指定远程Kurento媒体服务。<br>一旦Kurento客户端被实例化，就可以和Kurento媒体服务器进行通信了，并且能够控制它的多媒体功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableWebSocket</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HelloWorldHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorldHandler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 被实例化成Spring Bean的KurentoClient</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> KurentoClient <span class="title">kurentoClient</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KurentoClient.create();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</div><div class="line">        registry.addHandler(handler(), <span class="string">"/helloworld"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> SpringApplication(HelloWorldApp.class).run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个web应用程序遵循单页面应用架构(SPA)，并使用并使用WebSocket以请求/响应的方式将客户端与应用服务器通信。具体来说，主程序类实现了WebSocketConfigurer接口，注册了WebSocketHanlder来处理来处理/helloworld中的WebSocket请求。<br>HelloWorldHandler类实现TextWebSocketHandler接口，来处理文本WebSocket请求。该类的核心方法是handleTextMessage。此方法接收请求并执行对应操作，通过WebSocket返回响应。换句话说，它实现了在前面的序列图中描述的信令协议的服务器部分。handleTextMessage方法中有个start逻辑，下面重点看下start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> WebSocketSession session, JsonObject jsonMessage)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 1. Media logic (webRtcEndpoint in loopback)</span></div><div class="line">        MediaPipeline pipeline = kurento.createMediaPipeline();</div><div class="line">        WebRtcEndpoint webRtcEndpoint = <span class="keyword">new</span> WebRtcEndpoint.Builder(pipeline).build();</div><div class="line">        webRtcEndpoint.connect(webRtcEndpoint);</div><div class="line"></div><div class="line">        <span class="comment">// 2. Store user session</span></div><div class="line">        UserSession user = <span class="keyword">new</span> UserSession();</div><div class="line">        user.setMediaPipeline(pipeline);</div><div class="line">        user.setWebRtcEndpoint(webRtcEndpoint);</div><div class="line">        users.put(session.getId(), user);</div><div class="line"></div><div class="line">        <span class="comment">// 3. SDP negotiation</span></div><div class="line">        String sdpOffer = jsonMessage.get(<span class="string">"sdpOffer"</span>).getAsString();</div><div class="line">        String sdpAnswer = webRtcEndpoint.processOffer(sdpOffer);</div><div class="line"></div><div class="line">        JsonObject response = <span class="keyword">new</span> JsonObject();</div><div class="line">        response.addProperty(<span class="string">"id"</span>, <span class="string">"startResponse"</span>);</div><div class="line">        response.addProperty(<span class="string">"sdpAnswer"</span>, sdpAnswer);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (session) &#123;</div><div class="line">            session.sendMessage(<span class="keyword">new</span> TextMessage(response.toString()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 4. Gather ICE candidates</span></div><div class="line">        webRtcEndpoint.addIceCandidateFoundListener(<span class="keyword">new</span> EventListener&lt;IceCandidateFoundEvent&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(IceCandidateFoundEvent event)</span> </span>&#123;</div><div class="line">                JsonObject response = <span class="keyword">new</span> JsonObject();</div><div class="line">                response.addProperty(<span class="string">"id"</span>, <span class="string">"iceCandidate"</span>);</div><div class="line">                response.add(<span class="string">"candidate"</span>, JsonUtils.toJsonObject(event.getCandidate()));</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (session) &#123;</div><div class="line">                        session.sendMessage(<span class="keyword">new</span> TextMessage(response.toString()));</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    log.error(e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        webRtcEndpoint.gatherCandidates();</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        sendError(session, t.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>配置媒体处理逻辑：这一部分是配置Kurento如何处理媒体换句话说，媒体管道是在这里创建的，因此，使用KurentoClient对象来创建MediaPipeline对象。使用它，我们需要的媒体元素被创建和连接。在本例中，我们只实例化一个WebRtcEndpoint来接收WebRTC流并将其发送回客户端。</li>
<li>存储用户会话：为了在Kurento媒体服务器中释放资源，我们存储用户会话(即MediaPipeline和WebRtcEndpoint)，以便在调用stop方法时执行释放操作。</li>
<li>WebRTC SDP谈判：在WebRTC，SDP(会话描述协议)用于协商对等节点之间的媒体交换。这种谈判是基于SDP提供和回答交换机制。这个协商在processRequest方法的第三部分完成，使用从浏览器客户端获得的SDP offer并返回由WebRtcEndpoint生成的SDP答案</li>
<li>收集ICE候选人：从版本6开始，Kurento完全支持Trickle ICE协议。因此，WebRtcEndpoint可以异步接收ICE候选。为了处理这个问题，每个WebRtcEndpoint提供一个监听器（addOnIceGatheringDoneListener），当ICE收集过程完成时触发事件。</li>
</ol>
<h5 id="客户端逻辑"><a href="#客户端逻辑" class="headerlink" title="客户端逻辑"></a>客户端逻辑</h5><p>现在我们来看看应用程序的客户端。要在服务器端调用先前创建的WebSocket服务，我们使用JavaScript WebSocket。我们使用一个特定的Kurento JavaScript类库库(kurento-utils.js)来简化WebRTC与服务端的交互。这个库依赖于adapter.js，它是一个由Google维护的JavaScript WebRTC实用程序，它抽象出浏览器的差异。最后，jquery.js在这个应用程序中也是需要的。<br>这些库在index.html网页中链接，并在index.js中使用。在下面的代码片段中，我们可以看到路径/ helloworld中WebSocket（变量ws）的创建。然后，使用WebSocket的onmessage监听器在客户端实现JSON信令协议。请注意，有三个传入消息到客户端：startResponse、error和iceCandidate。采取方便的行动来实施沟通的每一个步骤。比如，在start函数中使用kurento-utils.js的WebRtcPeer.WebRtcPeerSendrecv来启动WebRTC通信。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://'</span> + location.host + <span class="string">'/helloworld'</span>);</div><div class="line"></div><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> parsedMessage = <span class="built_in">JSON</span>.parse(message.data);</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">'Received message: '</span> + message.data);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (parsedMessage.id) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'startResponse'</span>:</div><div class="line">            startResponse(parsedMessage);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'error'</span>:</div><div class="line">            <span class="keyword">if</span> (state == I_AM_STARTING) &#123;</div><div class="line">                setState(I_CAN_START);</div><div class="line">            &#125;</div><div class="line">            onError(<span class="string">'Error message from server: '</span> + parsedMessage.message);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'iceCandidate'</span>:</div><div class="line">            webRtcPeer.addIceCandidate(parsedMessage.candidate, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (error)</div><div class="line">                    <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'Error adding candidate: '</span> + error);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">if</span> (state == I_AM_STARTING) &#123;</div><div class="line">                setState(I_CAN_START);</div><div class="line">            &#125;</div><div class="line">            onError(<span class="string">'Unrecognized message'</span>, parsedMessage);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting video call ...'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Disable start button</span></div><div class="line">    setState(I_AM_STARTING);</div><div class="line">    showSpinner(videoInput, videoOutput);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Creating WebRtcPeer and generating local sdp offer ...'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> options = &#123;</div><div class="line">        <span class="attr">localVideo</span>: videoInput,</div><div class="line">        <span class="attr">remoteVideo</span>: videoOutput,</div><div class="line">        <span class="attr">onicecandidate</span>: onIceCandidate</div><div class="line">    &#125;</div><div class="line">    webRtcPeer = <span class="keyword">new</span> kurentoUtils.WebRtcPeer.WebRtcPeerSendrecv(options,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (error)</div><div class="line">                <span class="keyword">return</span> <span class="built_in">console</span>.error(error);</div><div class="line">            webRtcPeer.generateOffer(onOffer);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="WebRTC-magic-mirror"><a href="#WebRTC-magic-mirror" class="headerlink" title="WebRTC magic mirror"></a>WebRTC magic mirror</h4><p>此Web应用程序由环回的WebRTC视频通信组成，在检测到的人脸上添加一个滑稽的帽子。这是一个计算机视觉和增强现实滤镜的例子。此Web应用程序扩展了Hello World教程，将媒体处理添加到基本WebRTC并回传。所以整个测试流程和Hello World教程差不多，只是有一个地方需要注意下。在start方法中多了个FaceOverlayFilter的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FaceOverlayFilter faceOverlayFilter = <span class="keyword">new</span> FaceOverlayFilter.Builder(pipeline).build();</div><div class="line"></div><div class="line">String appServerUrl = System.getProperty(<span class="string">"app.server.url"</span>,</div><div class="line">        MagicMirrorApp.DEFAULT_APP_SERVER_URL);</div><div class="line">faceOverlayFilter.setOverlayedImage(appServerUrl + <span class="string">"/img/mario-wings.png"</span>, -<span class="number">0.35F</span>, -<span class="number">1.2F</span>,<span class="number">1.6F</span>, <span class="number">1.6F</span>);</div></pre></td></tr></table></figure></p>
<p>上面appServerUrl + “/img/mario-wings.png”是帽子图片的地址，Kurento服务器中会用到，所以要保证Kurento服务器能够访问到该地址，我是将该图片上传到云端，可以正常通过测试。<br>该项目模块为kurento-magic-mirror。</p>
<h4 id="WebRTC-one-to-many-broadcast"><a href="#WebRTC-one-to-many-broadcast" class="headerlink" title="WebRTC one-to-many broadcast"></a>WebRTC one-to-many broadcast</h4><p>WebRTC的视频广播。一个对等体发送一个视频流，N个对等体接收它。<br>这个Web应用程序由使用WebRTC技术的一对多视频通话组成。换句话说，这是一个视频广播Web应用程序的实现。测试流程和Hello World教程差不多，该项目模块为kurento-one2many-call。</p>
<h4 id="WebRTC-one-to-one-video-call"><a href="#WebRTC-one-to-one-video-call" class="headerlink" title="WebRTC one-to-one video call"></a>WebRTC one-to-one video call</h4><p>该Web应用程序是基于WebRTC的可视电话（一对一呼叫）。此Web应用程序使用WebRTC技术进行一对一视频通话。换句话说，这个应用程序提供了一个简单的视频软电话。测试流程和Hello World教程差不多，该项目模块为kurento-one2one-call。</p>
<h4 id="WebRTC-one-to-one-video-call-with-recording-and-filtering"><a href="#WebRTC-one-to-one-video-call-with-recording-and-filtering" class="headerlink" title="WebRTC one-to-one video call with recording and filtering"></a>WebRTC one-to-one video call with recording and filtering</h4><p>这是视频录制和增强现实的一对一应用程序的增强版本。这个Web应用程序包含一个使用WebRTC技术的先进的一对一视频通话。这是one-to-one video call的改进版本。这里同样涉及到图片的问题，参照WebRTC magic mirror，其它流程都一样。该项目模块为kurento-one2one-call-advanced。</p>
<h4 id="WebRTC-many-to-many-video-call-Group-call"><a href="#WebRTC-many-to-many-video-call-Group-call" class="headerlink" title="WebRTC many-to-many video call (Group call)"></a>WebRTC many-to-many video call (Group call)</h4><p>本教程将几个参与者连接到同一个视频会议。组播呼叫将在媒体服务器端以N * N个WebRTC端点出现，其中N是连接到该会议的客户端的数量。本教程演示了如何使用房间的概念，允许使用WebRTC技术在它们之间连接多个客户端，从而创建一个多会议模式。测试流程和Hello World教程差不多，该项目模块为kurento-group-call。</p>
<h4 id="Media-Elements-metadata"><a href="#Media-Elements-metadata" class="headerlink" title="Media Elements metadata"></a>Media Elements metadata</h4><p>本教程将在webcam视频中检测并绘制人脸。演示连接两个过滤器，KmsDetectFaces和KmsShowFaces。测试流程和Hello World教程差不多，该项目模块为kurento-metadata-example。但是有一点需要注意下，需要在Kurento服务器中安装kms-datachannelexample，并重启Kurento服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install kms-datachannelexample</div><div class="line">sudo service kurento-media-server-6.0 restart</div></pre></td></tr></table></figure></p>
<h4 id="Play-media-to-WebRTC"><a href="#Play-media-to-WebRTC" class="headerlink" title="Play media to WebRTC"></a>Play media to WebRTC</h4><p>本教程从磁盘读取文件并将视频播放到WebRTC。本教程将打开一个URL并将其内容播放到WebRTC，在这里可以选择播放视频和音频，只播放视频还是只播放音频。测试流程和Hello World教程差不多，该项目模块为kurento-player。</p>
<h4 id="WebRTC-outgoing-data-channels"><a href="#WebRTC-outgoing-data-channels" class="headerlink" title="WebRTC outgoing data channels"></a>WebRTC outgoing data channels</h4><p>本教程将播放器连接到QR码检测过滤器，并将输出发送到WebRTC。使用WebRTC数据通道将代码检测事件发送到浏览器。测试流程和Media Elements metadata差不多，需要安装额外的模块：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install kms-datachannelexample</div></pre></td></tr></table></figure></p>
<p>该项目模块为kurento-send-data-channel。</p>
<h4 id="WebRTC-incoming-data-channel"><a href="#WebRTC-incoming-data-channel" class="headerlink" title="WebRTC incoming data channel"></a>WebRTC incoming data channel</h4><p>本教程展示了从浏览器发送的文本消息如何通过数据通道传送，并与回送视频一起显示。测试流程和Hello World教程差不多，该项目模块为kurento-show-data-channel。</p>
<h4 id="WebRTC-recording"><a href="#WebRTC-recording" class="headerlink" title="WebRTC recording"></a>WebRTC recording</h4><p>本教程有两个部分。首先，它实现一个WebRTC环回，并将流记录到磁盘。其次，它播放录制的流。用户可以选择要发送和录制的媒体类型：音频，视频或两者。<br>测试流程和Hello World教程差不多，该项目模块为kurento-hello-world-recording。</p>

    
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xvag5.com1.z0.glb.clouddn.com/zhangjing.jpg"
               alt="bboyjing" />
          <p class="site-author-name" itemprop="name">bboyjing</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">98</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://mokaikai.github.io/" title="500" target="_blank">500</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://bailaohe.github.io/" title="bailaohe" target="_blank">bailaohe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.lamborryan.com/" title="追风的蓝宝" target="_blank">追风的蓝宝</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bboyjing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
